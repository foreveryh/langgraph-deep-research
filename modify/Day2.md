Here's the plan for Day 2, focusing on implementing the multi-task loop and initial reasoning capabilities. This will be for Cursor to implement.

---
## AI IDE Guidance: Day 2 Implementation Plan

**Background for Cursor:**

"Cursor, fantastic work on Day 1! We've successfully introduced the `planner_node`, updated our `OverallState` to include a `plan` and `current_task_pointer`, and refactored `generate_query` to work Ã¡tomos this plan. The agent can now create a multi-step research plan and execute the *first* task of that plan, including web research and initial reflection.

**Day 2 Objective: Implement Multi-Task Iteration and Preliminary Reasoning Consolidation**

Today, our main goals are:

1.  **Implement the core loop** to iterate through all tasks in the `plan` generated by `planner_node`.
2.  Introduce a basic mechanism to **consolidate findings** from each task into a progressively built-up knowledge base (our first step towards the `ledger` and `global_summary_memory` concepts from the "DeepResearch" ideal).
3.  Refine state updates to accurately track progress through the multi-step plan.

**Thinking and Implementation Directions for Cursor:**

1.  **State (`OverallState`) Enhancements (`agent/state.py`):**
    * **Introduce `ledger: Annotated[List[Dict[str, Any]], operator.add]`**:
        * This will be a list to store a simple summary or key findings from each completed task.
        * Each entry in the `ledger` could be a dictionary, for example: `{"task_id": "task-1", "description": "Original task description", "findings_summary": "A brief summary of what was found for this task."}`.
        * The `operator.add` will allow nodes to easily append new entries.
    * **Introduce `global_summary_memory: Annotated[List[str], operator.add]` (Simplified Initial Version)**:
        * This will be a list of strings. After each task's reflection (or a new dedicated reasoning step), we'll append a concise summary of that task's outcome here.
        * This is a precursor to the more complex, LLM-compressed global memory. For now, simple appending is fine.
    * **Ensure `research_loop_count` is reset or managed per task if necessary**: The current `research_loop_count` in `OverallState` might be global. Consider if it needs to be reset for each task in the `plan` or if its current use is still appropriate. For now, we can assume it's for the sub-loops within a single task's research/reflection cycle.

2.  **Modify/Create Conditional Edge for Task Iteration (`agent_graph.py` or wherever edges are defined):**
    * The key change today is how the graph handles the completion of a single task's research and reflection cycle (currently ending after `evaluate_research`).
    * **New Conditional Edge Function**: Let's call it `decide_next_step_in_plan`. This function will be called after `evaluate_research` (or potentially after a task is fully "completed" by `reflection`).
    * **Logic for `decide_next_step_in_plan(state: OverallState)`**:
        1.  Retrieve `current_task_pointer` and `plan` from the state.
        2.  Get the `current_task = state["plan"][state["current_task_pointer"]]`.
        3.  **Decision Point 1 (Based on `evaluate_research`'s output for the current task):**
            * If `evaluate_research` decided to `Send` more queries to `web_research` (i.e., `state["is_sufficient"]` was false and loops weren't exhausted for the *current task*), then the graph should route back to `web_research` as it currently does. `decide_next_step_in_plan` might just pass through this decision if `evaluate_research` already returns `Send` objects.
            * However, if `evaluate_research` determined the *current task* is "sufficient" OR its research loops are maxed out (i.e., it would have returned "finalize_answer" in the old single-task setup), then this new function takes over.
        4.  **Action for a "Completed" Task**:
            * **Log/Summarize Task Findings**: This is where we'd ideally call a small utility or a new mini-node to summarize the `state["web_research_result"]` (perhaps just the latest additions if it's cumulative) for the *just-completed task*. Let this summary be `task_findings_summary`.
            * Update `OverallState`:
                * Append to `ledger`: `{"task_id": current_task["id"], "description": current_task["description"], "findings_summary": task_findings_summary}`.
                * Append `task_findings_summary` (or a further condensed version) to `global_summary_memory`.
                * Mark the current task as "completed" in the `plan`: `state["plan"][state["current_task_pointer"]]["status"] = "completed"`.
        5.  **Decision Point 2 (Move to next task or finalize):**
            * Increment `current_task_pointer`: `new_pointer = state["current_task_pointer"] + 1`.
            * Update `state["current_task_pointer"] = new_pointer`.
            * If `new_pointer < len(state["plan"])`:
                * It means there are more tasks. Route back to `generate_query` to start the next task. Reset any per-task counters if necessary (e.g., `research_loop_count` could be reset here if it's meant to be per-task).
            * Else (`new_pointer >= len(state["plan"])`):
                * All tasks in the plan are completed. Route to `finalize_answer`.
    * **Graph Edge Adjustments**:
        * The edge previously going from `reflection` (conditionally via `evaluate_research`) to `finalize_answer` or `web_research` will now go to this new conditional edge function `decide_next_step_in_plan`.
        * `decide_next_step_in_plan` will then have conditional edges:
            * To `generate_query` (if there's a next task).
            * To `finalize_answer` (if all tasks are done).
            * (It might also implicitly allow routing back to `web_research` if `evaluate_research` determined the current task needs more sub-loops, though this might be better handled by making `evaluate_research` directly return `Send` objects or the name of the next node *within the current task's sub-loop*). For simplicity, let's assume `evaluate_research`'s output (if not "finalize_answer" for the *whole plan*) is handled first for the sub-loop. `decide_next_step_in_plan` primarily decides *between tasks* or *finishing the plan*.

3.  **Refine `reflection` Node (`agent/nodes.py` or equivalent):**
    * While `reflection` currently produces `is_sufficient`, `knowledge_gap`, `follow_up_queries` for the *current task's sub-loop*, ensure its output can be used by `decide_next_step_in_plan` to create the `task_findings_summary` for the `ledger` and `global_summary_memory`.
    * Perhaps `reflection` can return an additional key like `"current_task_summary"` which is a concise summary of the findings for the task it just reflected upon.
    * Alternatively, a new small node `summarize_task_findings_node` could be inserted after a task's research/reflection loop is deemed complete by `evaluate_research`, just before `decide_next_step_in_plan`. This node would take `state["web_research_result"]` (perhaps filtered for the current task) and produce the summary.

4.  **Modify `finalize_answer` Node (`agent/nodes.py` or equivalent):**
    * It should now use the accumulated `state["ledger"]` and/or `state["global_summary_memory"]` as the primary context for generating the final answer, rather than just the raw `state["web_research_result"]`.
    * The `answer_instructions` prompt will need to be updated to reflect that it's receiving a series of summarized findings or a global summary.

**Code Snippet Ideas (for Cursor's inspiration):**

**1. `agent/state.py` (Additions to `OverallState`)**
```python
# ...
class LedgerEntry(TypedDict): # Or a Pydantic model if preferred for structure
    task_id: str
    description: str
    findings_summary: str
    # raw_snippets: Optional[List[str]] # Optional: for more detail

class OverallState(TypedDict):
    # ... existing fields from Day 1 ...
    user_query: Optional[str]
    plan: Optional[List[Dict[str, Any]]]
    current_task_pointer: Optional[int]
    executed_search_queries: Annotated[List[str], operator.add]

    # --- New for Day 2 ---
    ledger: Annotated[List[LedgerEntry], operator.add]
    global_summary_memory: Annotated[List[str], operator.add] # List of strings for now
    # Ensure all fields used by existing nodes are present and correctly typed
```

**2. `decide_next_step_in_plan` (New conditional edge function)**
```python
# (In your graph definition file)
def summarize_for_ledger(current_task_description: str, web_results: List[str], llm) -> str:
    # This is a helper or could be a mini-node.
    # Uses LLM to create a concise summary of web_results for the current task.
    # Keep it simple for now.
    if not web_results:
        return "No specific new findings for this task."
    context_to_summarize = "\n---\n".join(web_results[-5:]) # Example: summarize last 5 results
    prompt = f"""Given the task: "{current_task_description}",
    And the following research snippets:
    {context_to_summarize}
    Please provide a very concise summary (1-2 sentences) of the key findings for this task.
    Summary:"""
    # llm should be an initialized ChatGoogleGenerativeAI instance
    response = llm.invoke(prompt)
    return response.content if hasattr(response, 'content') else str(response)


def decide_next_step_in_plan(state: OverallState, config: RunnableConfig) -> str: # Returns name of next node
    current_pointer = state.get("current_task_pointer", 0)
    plan = state.get("plan", [])
    current_task = plan[current_pointer]

    # This function is called *after* evaluate_research has determined the current task's
    # sub-loop (of research & reflection) is complete.
    # So, we proceed to log this task's findings and decide on the overall plan.

    # 1. Summarize and log findings for the just-completed task
    #    (Ideally, reflection_node or a new node should prepare this summary)
    #    For now, let's assume reflection_node added a "current_task_reflection_summary" to state,
    #    or we create a simple one here.
    #    This part needs careful thought: how to get only the *current task's* web_research_result?
    #    If web_research_result is always appended, we need a way to know which entries belong to current task.
    #    Simplification for Day 2: Assume reflection_node provides a summary of its work.
    
    # Let's assume 'reflection' node now also returns a 'task_summary' field
    # Or we call a utility here. For Day 2, let's assume we can get a summary.
    # We need an LLM instance here for the summarizer, or reflection node must provide it.
    # Quick fix: reflection node could output a "current_task_summary"
    task_summary_for_ledger = state.get("current_task_summary", f"Completed: {current_task['description']}")


    # This is where you'd update the actual state. LangGraph does this based on the *node's return*.
    # Conditional edges themselves *don't update state*.
    # So, the summarization & ledger update should happen in a *node* that runs *before* this conditional edge.
    # Let's assume a node like "record_task_completion" runs after "evaluate_research" says a task is done,
    # and *before* "decide_next_step_in_plan".
    # "record_task_completion" would return:
    # {
    #   "ledger": [{"task_id": ..., "description": ..., "findings_summary": ...}], # to be appended
    #   "global_summary_memory": [task_summary_for_ledger], # to be appended
    #   "plan": updated_plan_with_status, # to replace
    #   "current_task_pointer": new_pointer # to replace
    # }
    # For today, let's simplify and focus on the routing logic. The state update mechanism needs a dedicated node.

    # --- Routing Logic ---
    next_pointer = current_pointer + 1

    if next_pointer < len(plan):
        print(f"--- Task '{current_task['description']}' completed. Moving to next task. ---")
        # The state update for current_task_pointer should happen in a node
        # This conditional edge just decides the *name* of the next node.
        # We need a mechanism to pass {"current_task_pointer": next_pointer} to the state.
        # For now, this routing implies a node will handle state update for pointer.
        # A simple way: have a node "prepare_next_task" that just updates the pointer.
        return "prepare_next_task_node" # This new node would update pointer and then go to generate_query
    else:
        print("--- All tasks in the plan are completed. Finalizing answer. ---")
        return "finalize_answer"

# You'll need a new node:
# def prepare_next_task_node(state: OverallState):
#   current_pointer = state.get("current_task_pointer", 0)
#   plan = state.get("plan", [])
#   # Also, the 'record_task_completion' logic should be here or in a node just before this.
#   # For now, just focusing on pointer.
#   updated_plan = list(plan)
#   if current_pointer < len(updated_plan):
#       updated_plan[current_pointer]["status"] = "completed"
#
#   # Create ledger entry (example)
#   task_summary_from_reflection = state.get("last_task_summary", "Summary N/A") # Assuming reflection adds this
#   ledger_entry = {
#       "task_id": plan[current_pointer]["id"],
#       "description": plan[current_pointer]["description"],
#       "findings_summary": task_summary_from_reflection
#   }
#   next_ptr = current_pointer + 1
#   return {
#       "current_task_pointer": next_ptr,
#       "plan": updated_plan, # to update status
#       "ledger": [ledger_entry], # to append via operator.add
#       "global_summary_memory": [task_summary_from_reflection] # to append
#   }


# In your graph definition:
# builder.add_node("record_and_prepare_next_task", record_and_prepare_next_task_node)
#
# After evaluate_research, if a task is 'done' (not sending back to web_research):
# It would go to "record_and_prepare_next_task".
# builder.add_conditional_edges(
#     "evaluate_research_output_node", # or whatever node evaluate_research routes to for "done task"
#     decide_next_step_in_plan, # This function now just routes
#     {
#         "prepare_next_task_node": "generate_query", # if decide_next_step_in_plan returns "prepare_next_task_node"
#                                                   # Actually, prepare_next_task_node should itself route to generate_query
#                                                   # So, decide_next_step_in_plan routes to "prepare_next_task_node" OR "finalize_answer"
#                                                   # Then, "prepare_next_task_node" has a direct edge to "generate_query"
#         "finalize_answer": END
#     }
# )
# This part of graph definition is tricky and needs care.
# The key is: conditional edges decide *routing*, actual state updates happen in *nodes*.
# You might need an intermediate node after `evaluate_research` (if it doesn't loop back to `web_research`)
# that *records the completion of the current task* (updating ledger, memory, plan status)
# and then `decide_next_step_in_plan` is called.
#
# Revised Flow Idea:
# ... -> reflection -> evaluate_research
# evaluate_research routes to:
#   - "web_research" (if current task needs more loops, via Send)
#   - "record_task_completion_node" (if current task is deemed sufficient by evaluate_research)
#
# builder.add_node("record_task_completion", record_task_completion_node) # This node updates ledger, memory, plan status for current task
# builder.add_edge("record_task_completion", "decide_next_step_in_plan_router_node") # This is just a name for where the conditional edge starts
#
# builder.add_conditional_edges(
#   "decide_next_step_in_plan_router_node", # Source from where conditional logic is applied
#   decide_next_step_in_plan_conditional_function, # The function that returns "generate_query" or "finalize_answer"
#   {
#       "generate_query": "generate_query", # if we need to start the next task (pointer already updated by record_task_completion_node)
#       "finalize_answer": "finalize_answer"
#   }
# )
# The function `record_task_completion_node` would be responsible for:
# 1. Creating ledger entry and memory entry for the task `state["plan"][state["current_task_pointer"]]`.
# 2. Updating `state["plan"][state["current_task_pointer"]]["status"] = "completed"`.
# 3. Incrementing `state["current_task_pointer"]`.
# 4. Returning all these updates.
# Then, `decide_next_step_in_plan_conditional_function` would simply check `state["current_task_pointer"]` against `len(state["plan"])`.
```

**Important Considerations for Cursor:**

* **State Update Atomicity**: Remember that nodes update the state by returning dictionaries. Conditional edge functions only decide the next node. Therefore, any state modifications (like updating `current_task_pointer`, `ledger`, `plan` status) must happen within a node. You might need to introduce small utility nodes if existing nodes aren't suitable placeholders for these updates. A node like `record_and_prepare_next_task_node` (executed when a task is finished) would be a good place to update `ledger`, `global_summary_memory`, `plan[task].status`, and `current_task_pointer`.
* **Clarity of `web_research_result`**: If `web_research_result` is a continuously growing list in `OverallState`, you'll need a strategy for `reflection` or the new `record_and_prepare_next_task_node` to identify which parts of `web_research_result` pertain to the *current task* to summarize them for the `ledger`. One way is for `web_research` to also return the `task_id` with its results, or for `reflection` to work on a subset passed to it. For Day 2, a simpler approach is that `reflection`'s output implicitly becomes the summary for the current task.
* **Prompt Engineering**: The prompts for summarizing task findings (for `ledger` and `global_summary_memory`) and for `finalize_answer` (using these new consolidated contexts) will need careful design.

This is a significant step. Focus on getting the loop correct and the basic `ledger`/`memory` appends working. We can refine the summarization quality and state management details in subsequent iterations. Good luck, Cursor!